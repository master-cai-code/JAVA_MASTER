# lambda 表达式   （参数列表）-> {方法体}                    
  ### 1. 函数式接口（适用于接口只有一个抽象方法）
       创建实现类 --> 匿名实现类 --> lambda --> 方法引用     为简化书写
       
       匿名实现类：直接 new 接口名（）{@Override ... }
       lambda   ： 接口名 变量名 = （）-> { }        参数推断，根据接口名找到接口里面的抽象方法（唯一的抽象方法，无歧义）
       方法引用  ：   简化lambda，分为静态方法，普通方法，构造函数
                 静态方法：   函数式接口  变量名 = 类名：：方法名
                 普通方法：   函数式接口  变量名 = 对象：：方法名   也可以 类名：：方法名
                 构造函数：   函数式接口  变量名 = 类名：：new      有参无参都是 类名：：new ，根据函数式接口决定
                 
       函数式接口：   Consumer<T>     代表了接受一个输入参数并且无返回的操作
                     Supplier<T>     无参数，返回一个结果。
                     Function<T,R>   接受一个输入参数，返回一个结果。
                     Predicate<T>    接受一个输入参数，返回一个布尔值结果。
                   复习： ---泛型：泛型接口（接口名<T>），泛型类(类名<T>)， 泛型方法(方法的返回值前面加 <T> )  
                          ---反射： 得到Class对象的方法  1. Class.forName("全类名")
                                                        2. 类名.class
                                                        3. 对象.getClass（）
                                带有Declared修饰的方法可以反射到私有的，没有Declared修饰的只能用来反射公有的。
                             
# stream API    
####  流式思想：对一组数据（集合或数组）进行多步"加工"，得到最终"产品"  （每个元素都进行加工）     
    1.特点：                                     
              1.1. 只负责计算，不存储数据
              1.2. 不改变源数据，会生成新的数据
              1.3. 延迟操作（触发终止操作时才开始执行中间操作）
    2.中间操作：
         filter（）  过滤操作，用于筛选符合条件的数据
         skip（）    跳跃，筛选指定范围的数据
         limit（）   限制，输出指定的个数
         distinct（）去重，去除重复元素
         
         sorted（）  排序，根据指定方法排序
         map（）     将流中的"每个元素"进行加工，形成新流（提取属性放入流中，不会合并成一个流）
         flatMap（） 也是对"每个元素"进行加工，不过会将所有流合并成一个流
         
         .....reduce（）、collect（）...
